\documentclass[a4paper,11pt,twocolumn]{article}

\usepackage[margin=3cm]{geometry}
\usepackage{xcolor}
\usepackage{listings}
\lstset{%
frame=single,
% framesep=13pt,
% framexleftmargin=7pt,
xleftmargin=20pt,
% fillcolor=\color{gray!10},
backgroundcolor = \color{gray!5},
rulecolor=\color{black!30},
numberstyle=\sffamily\color{black!75},
numbers = left,
% breaklines = true,
% showspaces = false,
basicstyle = \ttfamily\footnotesize,
tabsize = 2,
captionpos=b,
language=Haskell,
morekeywords={data,where},
keywordsprefix=\#,
alsoletter=\#
}

\newcommand{\malfunction}{\texttt{malfunction}}

\title{An Idris Foreign Function Interface to OCaml}
\author{Robert Atkey  $\langle$\texttt{robert.atkey@strath.ac.uk}$\rangle$ \\
  Ioan Luca $\langle$\texttt{ioan.luca7@gmail.com}$\rangle$}
\date{}

\begin{document}

\maketitle

\section{Introduction}

Idris is a strict functional language with dependent types intended
for practical use \cite{idrisbook}. Unfortunately, due to the
relatively small size of the Idris user community, the ecosystem of
available libraries for practical programming is limited. To remedy
this, we have constructed a Foreign Function Interface (FFI) for Idris
to call OCaml libraries. We have extended Dolan's backend
\cite{dolan2016malfunctional} for the Idris compiler that generates
Malfunction (a concrete syntax for the OCaml compiler's `Lambda`
intermediate language) with the ability to call arbitrary OCaml
libraries. Using this facility, we have been able to call higher order
functions in OCaml's \texttt{List} library, use the \texttt{Cohttp}
library to make a web server with the callback function written in
Idris using the \texttt{Lwt} library, and to construct a simple Mirage
unikernel written in Idris. In the latter case, we needed to export an
implementation of an OCaml functor from Idris to fit with Mirage's
functorised design.

In the talk, we will report on and demo the modifications we have made
to Dolan's Malfunction backend, and the progress we have made in
expressing the complex OCaml type system in Idris.

Idris's dependent types offer an expressive language for describing
types, which we have used to expose a simple fragement of the module
system in Idris.  However, ergonomic expression of module types, that
allow the use of names for looking up structure entries is not yet
possible (only type safe lookup by index is possible). The nominal
type systems of both languages also present problems when attempting
to use structural descriptions of data types.


% This entails constructing an FFI for Idris to interface with
%   OCaml programs. FFIs have been constructed for other backends, but
%   these backends are either to languages with simpler type systems
%   (e.g., C), or to languages with no static type system at all
%   (JavaScript, Erlang). When both sides of the FFI have complex type
%   systems, a common solution is to restrict to a subset of the
%   intersection of the two type systems, often only allowing
%   monomorphic, non higher order types. We want to explore doing
%   something more expressive, so that we don't end up writing
%   translation code in OCaml for Idris to interface with.

% \begin{itemize}
% \item Idris is a dependently typed programming langauge
% \item OCaml isn't, but it has a lot of libraries
% \item Dolan's \texttt{malfunction} backend enables compilation from
%   Idris to machine code via the OCaml compiler, but only provides
%   limited support for calling external OCaml functions.
% \item We would like to exploit the possibility of compiling via the
%   OCaml backend to not only generate more efficient programs, but also
%   to access OCaml's library ecosystem.
% \item 
% \end{itemize}

% What we've done:
% \begin{enumerate}
% \item Improved the Idris \malfunction{} backend by not using Idris's
%   defunctionalised representation, and by using the same compilation
%   scheme
% \item Made an FFI definition for Idris that allows basic interaction
%   between OCaml and Idris code. This has allowed us to write a simple
%   web server in Idris, using the Cohttp library.
% \end{enumerate}

% \section{Background}

% \paragraph{Idris} %\footnote{\url{https://www.idris-lang.org/}}
% is a pure functional,
% general purpose, dependently typed programming language.
% Idris programs use types as the main building block which allows it
% to encode complex invariants directly into source code.
% This means that the compiler checks programs for
% correctness before they run, enabling
% ``lightweight verification''\footnote{specification is
% 	defined early in the development phase as a language construct;
% 	the implementing code is then guaranteed to work against it}.
% This has the potential to drastically reduce the costs
% of reliable software by integrating verification into development
% instead of considering it a separate concern.

% Despite being novel and popular amongst Programming Language research
% groups, Idris did not catch the attention of industrial developer
% communities.
% This is partly because the language lacks a high performance
% runtime system and partly because its library ecosystem has poor
% support for fast and reliable software.

% Idris \cite{idris} is a dependently typed language with a strict
% evaluation semantics. Idris's implementation has been written to allow
% pluggable backends. C and JavaScript backends are included with the
% main distribution, and

% \paragraph{The Idris compiler infrastructure}


% Idris is intended for general use. \cite{crosscompilers} argues
% that this raises the need for Idris to run in various, potentially
% very different environments.

% For example, it is possible to generate C to have Idris run
% natively or JavaScript to run in the browser.

% To address this concern, Idris provides a modular compiler
% infrastructure as a Haskell library in which different code
% generators can easily be plugged in.
% According to \cite{crosscompilers},
% the library exposes 4 different intermediate representations outside
% of Idris itself:
% \begin{enumerate}
%     \item TT --- a core language based on dependent type theory; fully
%           explicit types still exist at this stage, but the only top level
%           constructs are the data type declarations and function definitions
%           with pattern matching transformed into case expressions
%     \item IR\textsubscript{lift} --- essentially TT type checked; unused values
%           and types are erased;
%     \item IR\textsubscript{defunc} --- all functions are first-order
%           and fully applied after defunctionalisation is performed
%     \item IR\textsubscript{ANF} --- all are functions are in
%           \emph{Applicative Normal Form} where all arguments are trivial;
%           in practice that means they are either variables or constants;
%           Idris can even generate a form of bytecode for a simple
%           stack-based machine from this IR
% \end{enumerate}
% They all resemble the same information but at different levels
% of abstraction. This is because they assume certain sets of features
% in the target language such that choosing a rich IR
% for a low-level language would be a bad idea.
% \cite{ElliottIdrisErlang}.


% A code generator is a program that type checks and elaborates
% Idris programs using this library.
% It has to choose exactly one
% IR to generate code from.
% The process of creating a new code generator is well
% documented by \cite{ElliottIdrisErlang} which also does a great job
% at specifying the Idris IRs and the primitives.


% \paragraph{Malfunction}
% is a minimal, untyped program representation intended as a
% compilation target for functional languages.

% Malfunction is in fact a thin wrapper around the Lambda intermediate
% representation (IR) of OCaml meaning that compilers targeting it
% are compiled to native code by the OCaml compiler enjoying the
% \emph{flambda} optimisations and the garbage collector mentioned
% earlier \cite{dolan2016malfunctional}.

% Despite being a compilation target it is much more high-level:
% for instance, Malfunction has
% let bindings, recursive definitions, lambdas, very basic case
% expressions, higher order functions and arguments currying.

% As it us usually the case with low-level untyped languages, Malfunction
% has undefined behaviour.
% Its semantics is that of Lambda, namely an untyped Lambda Calculus but
% stricter in certain places which make it more robust to changes in the
% OCaml toolchain. \cite{dolan2016malfunctional}.

% Similarly, its syntax is based on s-expressions\footnote{
%     what Lisp looks like
% } which are easy to generate from many abstract syntax trees (ASTs).

% Recently, Malfunction received an upgrade.
% Now it also supports lazy evaluation and
% floating point numbers.


% \paragraph{OCaml} is a general purpose industrial-strength functional
% programming language with a high-performance runtime system

% According to \cite{rwocaml}, OCaml plays an important role in the
% world of programming language design because it provides a mix
% of expressiveness, efficiency and practicality.
% FIXME This mix, is in fact a collection of carefully chosen features
% that have been developed over the last 40 years.

% % TODO say that it doesn't have dependent types but still

% The OCaml compiler benefits from a simple
% compilation strategy that doesn't require heavy optimizations or
% complicated dynamic just-in-time (JIT) features to produce performant
% code. Moreover, OCaml is strictly evaluated just like Idris which
% makes it easy to predict performance.
% The language uses  a precise incremental garbage collection strategy
% that avoids spikes while the runtime is straightforward and highly
% portable.

% Normally, what also makes OCaml practical, is that it supports some
% imperative programming style constructs like mutable references,
% side effects and even objects.
% However, release 4.02 brought the \emph{flambda} optimisations to the
% native compiler. They are a series of tweaks
% that enable idiomatic functional programming characteristics like clojures,
% higher-order functions and immutability to be used at no extra
% performance cost.\cite{leroy2014ocaml}

% \paragraph{Idris-Malfunction}

% Originally, Stephen Dolan, the author of Malfunction created a
% version\footnote{hosted at
%     https://github.com/stedolan/idris-malfunction}
% of this backend \cite{dolan2016malfunctional}.
% Although incomplete, preliminary benchmarks showed that it was
% outperforming the default C backend by a factor between 3.2x and 14x
% which sounded promising.

% Besides missing a lot of functionality, the backend was generating
% inefficient code for Idris constructors which were always wrapped
% in a block of memory regardless whether they had any parameters.
% No parameters constructors can in fact map to integers directly.
% Moreover, the code was generated from IR\textsubscript{ANF}
% which did not seem optimal given that Malfunction has
% good support for higher-order functions.
% This is especially true now that laziness was added to Malfunction.

% Nevertheless, this version of the backend was a good place to start
% and build on.

% The current version of the backend which I built chooses
% to generate code from IR\textsubscript{lift} which seems to
% slightly improve the already good performance.

% The backend was tested with a range of benchmarks against the
% C backend:

% \paragraph{Benchmark results}
% The Unix ``time'' command was used as part of the binaries execution
% and all output was redirected to /dev/null.
% See tables \ref{tab:fibtab},
% \ref{tab:pythagtab} and
% \ref{tab:bintreetab}.

% \begin{table}
%     \centering
%     \caption{40th Fibonacci number --- naive}
%     \begin{tabular}{llll}\label{tab:fibtab}
%              & C      & OCaml  & \\
%         real & 5.050s & 3.851s & \\
%         user & 5.034s & 3.846s & \\
%         sys  & 0.01s  & 0.04s  &
%     \end{tabular}
% \end{table}

% \begin{table}
%     \centering
%     \caption{Generate the first 500 Pythagorean triplets in a linked list}
%     \begin{tabular}{llll}\label{tab:pythagtab}
%              & C      & OCaml  & \\
%         real & 3.163s & 0.417s & \\
%         user & 3.131s & 0.416s & \\
%         sys  & 0.027s & 0.01s  &
%     \end{tabular}
% \end{table}


% \begin{table}
%     \centering
%     \caption{Allocation of a perfect binary tree to \emph{stretch} memory, which then is deallocated, followed by an allocation of a long-lived perfect binary tree which will live-on while other trees are allocated and deallocated}
%     \begin{tabular}{llll}\label{tab:bintreetab}
%              & C       & OCaml   & \\
%         real & 58.114s & 18.967s & \\
%         user & 44.036s & 18.540s & \\
%         sys  & 13.980s & 0.346s  &
%     \end{tabular}
% \end{table}





% \section{OCaml Types in Idris}

% \begin{lstlisting}
% data OCaml_Types : Type -> Type where
%    OCaml_Str   : OCaml_Types String
%    OCaml_Float : OCaml_Types Double
%    OCaml_Bool  : OCaml_Types Bool
% \end{lstlisting}

% \paragraph{Primitive types}



% \paragraph{Function Types}

% \paragraph{Algebraic datatypes}

% \paragraph{Records}

% \paragraph{Modules}
% OCaml modules are a very powerful system for software modularisation. 
% It is interesting that they have a very simple runtime representation.
% Essentially,  modules are blocks of memory and functors are functions
% from blocks to blocks. The difference between modules(functors) and
% structs(functions) only exists at compile-time.


\begin{itemize}
\item Idris is a dependently typed programming langauge
\item OCaml isn't, but it has a lot of libraries
\item Dolan's \texttt{malfunction} backend enables compilation from
  Idris to machine code via the OCaml compiler, but only provides
  limited support for calling external OCaml functions.
\item We would like to exploit the possibility of compiling via the
  OCaml backend to not only generate more efficient programs, but also
  to access OCaml's library ecosystem.
\item This entails constructing an FFI for Idris to interface with
  OCaml programs. FFIs have been constructed for other backends, but
  these backends are either to languages with simpler type systems
  (e.g., C), or to languages with no static type system at all
  (JavaScript, Erlang). When both sides of the FFI have complex type
  systems, a common solution is to restrict to a subset of the
  intersection of the two type systems, often only allowing
  monomorphic, non higher order types. We want to explore doing
  something more expressive, so that we don't end up writing
  translation code in OCaml for Idris to interface with.
\end{itemize}

What we've done:
\begin{enumerate}
\item Improved the Idris \malfunction{} backend by not using Idris's
  defunctionalised representation, and by using the same compilation
  scheme
\item Made an FFI definition for Idris that allows basic interaction
  between OCaml and Idris code. This has allowed us to write a simple
  web server in Idris, using the Cohttp library.
\end{enumerate}

\section{Background}

\paragraph{Idris} %\footnote{\url{https://www.idris-lang.org/}}
is a pure functional,
general purpose, dependently typed programming language.
Idris programs use types as the main building block which allows it
to encode complex invariants directly into source code.
This means that the compiler checks programs for
correctness before they run, enabling
``lightweight verification''\footnote{specification is
	defined early in the development phase as a language construct;
	the implementing code is then guaranteed to work against it}.
This has the potential to drastically reduce the costs
of reliable software by integrating verification into development
instead of considering it a separate concern.

Despite being novel and popular amongst Programming Language research
groups, Idris did not catch the attention of industrial developer
communities.
This is partly because the language lacks a high performance
runtime system and partly because its library ecosystem has poor
support for fast and reliable software.

Idris \cite{idris} is a dependently typed language with a strict
evaluation semantics. Idris's implementation has been written to allow
pluggable backends. C and JavaScript backends are included with the
main distribution, and

\paragraph{The Idris compiler infrastructure}


Idris is intended for general use. \cite{crosscompilers} argues
that this raises the need for Idris to run in various, potentially
very different environments.

For example, it is possible to generate C to have Idris run
natively or JavaScript to run in the browser.

To address this concern, Idris provides a modular compiler
infrastructure as a Haskell library in which different code
generators can easily be plugged in.
According to \cite{crosscompilers},
the library exposes 4 different intermediate representations outside
of Idris itself:
\begin{enumerate}
    \item TT --- a core language based on dependent type theory; fully
          explicit types still exist at this stage, but the only top level
          constructs are the data type declarations and function definitions
          with pattern matching transformed into case expressions
    \item IR\textsubscript{lift} --- essentially TT type checked; unused values
          and types are erased;
    \item IR\textsubscript{defunc} --- all functions are first-order
          and fully applied after defunctionalisation is performed
    \item IR\textsubscript{ANF} --- all are functions are in
          \emph{Applicative Normal Form} where all arguments are trivial;
          in practice that means they are either variables or constants;
          Idris can even generate a form of bytecode for a simple
          stack-based machine from this IR
\end{enumerate}
They all resemble the same information but at different levels
of abstraction. This is because they assume certain sets of features
in the target language such that choosing a rich IR
for a low-level language would be a bad idea.
\cite{ElliottIdrisErlang}.


A code generator is a program that type checks and elaborates
Idris programs using this library.
It has to choose exactly one
IR to generate code from.
The process of creating a new code generator is well
documented by \cite{ElliottIdrisErlang} which also does a great job
at specifying the Idris IRs and the primitives.


\paragraph{Malfunction}
is a minimal, untyped program representation intended as a
compilation target for functional languages.

Malfunction is in fact a thin wrapper around the Lambda intermediate
representation (IR) of OCaml meaning that compilers targeting it
are compiled to native code by the OCaml compiler enjoying the
\emph{flambda} optimisations and the garbage collector mentioned
earlier \cite{dolan2016malfunctional}.

Despite being a compilation target it is much more high-level:
for instance, Malfunction has
let bindings, recursive definitions, lambdas, very basic case
expressions, higher order functions and arguments currying.

As it us usually the case with low-level untyped languages, Malfunction
has undefined behaviour.
Its semantics is that of Lambda, namely an untyped Lambda Calculus but
stricter in certain places which make it more robust to changes in the
OCaml toolchain. \cite{dolan2016malfunctional}.

Similarly, its syntax is based on s-expressions\footnote{
    what Lisp looks like
} which are easy to generate from many abstract syntax trees (ASTs).

Recently, Malfunction received an upgrade.
Now it also supports lazy evaluation and
floating point numbers.


\paragraph{OCaml} is a general purpose industrial-strength functional
programming language with a high-performance runtime system

According to \cite{rwocaml}, OCaml plays an important role in the
world of programming language design because it provides a mix
of expressiveness, efficiency and practicality.
FIXME This mix, is in fact a collection of carefully chosen features
that have been developed over the last 40 years.

% TODO say that it doesn't have dependent types but still

The OCaml compiler benefits from a simple
compilation strategy that doesn't require heavy optimizations or
complicated dynamic just-in-time (JIT) features to produce performant
code. Moreover, OCaml is strictly evaluated just like Idris which
makes it easy to predict performance.
The language uses  a precise incremental garbage collection strategy
that avoids spikes while the runtime is straightforward and highly
portable.

Normally, what also makes OCaml practical, is that it supports some
imperative programming style constructs like mutable references,
side effects and even objects.
However, release 4.02 brought the \emph{flambda} optimisations to the
native compiler. They are a series of tweaks
that enable idiomatic functional programming characteristics like clojures,
higher-order functions and immutability to be used at no extra
performance cost.\cite{leroy2014ocaml}

\paragraph{Idris-Malfunction}

Originally, Stephen Dolan, the author of Malfunction created a
version\footnote{hosted at
    https://github.com/stedolan/idris-malfunction}
of this backend \cite{dolan2016malfunctional}.
Although incomplete, preliminary benchmarks showed that it was
outperforming the default C backend by a factor between 3.2x and 14x
which sounded promising.

Besides missing a lot of functionality, the backend was generating
inefficient code for Idris constructors which were always wrapped
in a block of memory regardless whether they had any parameters.
No parameters constructors can in fact map to integers directly.
Moreover, the code was generated from IR\textsubscript{ANF}
which did not seem optimal given that Malfunction has
good support for higher-order functions.
This is especially true now that laziness was added to Malfunction.

Nevertheless, this version of the backend was a good place to start
and build on.

The current version of the backend which I built chooses
to generate code from IR\textsubscript{lift} which seems to
slightly improve the already good performance.

The backend was tested with a range of benchmarks against the
C backend:

\paragraph{Benchmark results}
The Unix ``time'' command was used as part of the binaries execution
and all output was redirected to /dev/null.
See tables \ref{tab:fibtab},
\ref{tab:pythagtab} and
\ref{tab:bintreetab}.

\begin{table}
    \centering
    \caption{40th Fibonacci number --- naive}
    \begin{tabular}{llll}\label{tab:fibtab}
             & C      & OCaml  & \\
        real & 5.050s & 3.851s & \\
        user & 5.034s & 3.846s & \\
        sys  & 0.01s  & 0.04s  &
    \end{tabular}
\end{table}

\begin{table}
    \centering
    \caption{Generate the first 500 Pythagorean triplets in a linked list}
    \begin{tabular}{llll}\label{tab:pythagtab}
             & C      & OCaml  & \\
        real & 3.163s & 0.417s & \\
        user & 3.131s & 0.416s & \\
        sys  & 0.027s & 0.01s  &
    \end{tabular}
\end{table}


\begin{table}
    \centering
    \caption{Allocation of a perfect binary tree to \emph{stretch} memory, which then is deallocated, followed by an allocation of a long-lived perfect binary tree which will live-on while other trees are allocated and deallocated}
    \begin{tabular}{llll}\label{tab:bintreetab}
             & C       & OCaml   & \\
        real & 58.114s & 18.967s & \\
        user & 44.036s & 18.540s & \\
        sys  & 13.980s & 0.346s  &
    \end{tabular}
\end{table}





\section{OCaml Types in Idris}

\begin{lstlisting}
data OCaml_Types : Type -> Type where
   OCaml_Str   : OCaml_Types String
   OCaml_Float : OCaml_Types Double
   OCaml_Bool  : OCaml_Types Bool
\end{lstlisting}


\begin{lstlisting}
data Values : List Type -> Type where
 Stop : Values []
 Step : t -> Values tys -> Values (t :: tys)

modGet :
  (i : Nat) -> OCamlModule tys      ->
  {auto ok : index' i tys = Just a} ->
  {auto p : OCaml_Types a}          -> 
  {auto q : OCamlTypeList tys}      ->
  OCaml_IO a
modGet {tys = tys} {a = a} i m = 
 ocamlCall "Idrisobj.field" 
  (OCamlModule tys -> Int -> OCaml_IO a) 
  m (cast i)


mkMod : 
    Values tys                   -> 
    {auto p : OCamlTypeList tys} ->
    OCaml_IO (OCamlModule tys)
mkMod {tys = tys} vs {p = p} = go vs p 0 
  where
  go : Values tys2        ->
       OCamlTypeList tys2 ->
       Int -> OCaml_IO (OCamlModule tys)
  go {tys2 = []} Stop Done n =
   ocamlCall "Idrisobj.new_block" 
      (Int -> Int -> 
       OCaml_IO (OCamlModule tys)) 
      0 n
  go {tys2 = ty :: tys2} 
    (Step v vs) (Next x q) n = do
     m <- go vs q (n + 1)
     ocamlCall "Idrisobj.set_field" 
       (OCamlModule tys -> Int 
       -> ty -> OCaml_IO ()) m n v
     pure m 
\end{lstlisting}

\paragraph{Primitive types}



\paragraph{Function Types}

\paragraph{Algebraic datatypes}

\paragraph{Records}

\paragraph{Modules}
OCaml modules are a very powerful system for software modularisation. 
It is interesting that they have a very simple runtime representation.
Essentially,  modules are blocks of memory and functors are functions
from blocks to blocks. The difference between modules(functors) and
structs(functions) only exists at compile-time.

In Idris, the following functions and data declarations are are used to 
describe them in a very raw way.

It is not yet possible to use module names.

% In Idris, the following functions and data declarations are are used to 
% describe them in a very raw way.

% It is not yet possible to use module names.

\section{Future Work}

\begin{itemize}
\item Polymorphism, properly. This is tricky because we need to insert
  the right coercions between Idris and OCaml types (especially the
  effectful ones). Do we need runtime type representations?
\item Algebraic datatypes, generally. We can write an encoding of
  algebraic datatypes in Idris, but this will be separate from Idris's
  native algebraic datatypes.
\item Properly reflecting the module system (related to the
  polymorphism problem)
\item Generating Idris type definitions from \texttt{.cmi} files.
\end{itemize}

\end{document}