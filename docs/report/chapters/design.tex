%10

\section{Overview}
A brief description of the various stages of compilation was
was already illustrated as part of \hyperref[ch:related]{Chapter~\ref{ch:related}}.

The overall architecture of the system
resembles the one that the other backends use and mainly
imposed by the Idris compiler library.

This system uses Idris as
a library to type check and elaborate Idris source files,
generate code which can then be compiled into native code,
or as a library to be linked with other OCaml code, as
it will be illustrated in the Mirage unikernel example.

There are three main components that this system relies on:
\begin{enumerate}
    \item The Code Generator (CG) --- it resides in the
          backend of the compiler; ensures that the semantics
          of the Idris source code is preserved at runtime
    \item The Foreign Call System --- defines the semantics
          of the Idris-OCaml interaction
    \item The Runtime System --- this is in fact the OCaml
          runtime which Malfunction compiles to;
\end{enumerate}
The Code Generator(CG) which resides in the
the backend of the compiler, the Foreign Call System which
lives in Idris source code and is processed by the compiler
frontend and the Runtime system.

\section{The Code Generator}
This one is written in Haskell as it needs to interfere
with the compiler library, which is also written in Haskell.

It used to be that the CG was made of two big files that became
unmanageable because of their size.
That being said, the CG is now split into modules, making
it easier to reason about components and improved the
GHC\footnote{Glasgow Haskell Compiler} compilation times.

\subsubsection{The Malfunction AST}
The old CG used to be able generate any possible
s-expressions. Not only is that error prone as not all of them
will be valid Malfunction syntax but the code generation
depends directly on the syntax which can change.

The CG defines the Malfunction
AST and the rules by which it is generated
from
IR\textsubscript{lift}. The Codegen module produces ASTs
which later knows how to write themselves to a file as
s-expressions.
IR\textsubscript{lift} is a suitable representation to generate
code from since Malfunction has all the features that this
IR assumes.

There is a CodegenUtils module that can determine which
definitions are recursive as they need special treatment
in Malfunction. It does that using graph connectivity.
The TranslateMonad represents a monadic structure used
to keep track of the current code generation state.
It holds a mapping from constructor names to tags as well
as the possibility of failure in the case of undefined
behaviour.

The CG is loosely coupled to the compiler frontend,
the interface between the two being very small.
That is, someone implementing this component does not need
to know about any of Idris' advanced features, like proof
obligations, totality checking or dependent types.

The NewCodegenMalfunction is the only entity that directly
communicates with the front end and it is responsible for
delegating the responsibilities to other modules as
soon as it receives the CodegenInfo. This module also creates
the Malfunction source file, and builds either the native binary
or the OCaml object files calling the \emph{malfunction}
external command.

One can specify the code generator Idris should use with
the \emph{--codegen } flag.
The C code generator is the default, but in our case
calling \emph{--codegen malfunction} will look for an
executable named \emph{idris-codegen-malfunction} on the
\emph{\$PATH} and call it with the compiled sources and
other compiler options.

The code generator knows when to create an Idris executable
by checking if any declarations are being exported.
In case there are, the system compiles the generated code
into an OCaml object file that exports the required declarations
and can later be linked in other OCaml libraries. At the time
of writing, the accompanying interface files are not
automatically generated and need to be written by hand.



\section{The Foreign Call System}
\subsection{Motivation}
A mechanism for calling native OCaml functions from
Idris must exist.
Some trivial small set of functional calls may work
because the data happens to have the same encoding on
both sides. However, that's not guaranteed in general:
Only because it has been generated from Idris, the Malfunction
AST won't look the same as if it was generated by OCaml itself.

For foreign calls, the Idris arguments types need to be converted
to what OCaml expects; Only then the function can be safely
called and the return type needs to be converted back to
something Idris can understand.

It's the other way around for exported functions: the OCaml
arguments need to be dynamically checked, converted to
the Idris representation, the result type being translated back
to OCaml.

\subsection{The new IO and FFI}
The IO monad is the parametric type that encapsulates the
interaction of Idris with the outside world, in our case --- OCaml.

When Idris was initially released, the built-in FFI was designed
to support only calls to C.

At the moment, Idris uses a generic
FFI that supports multiple platforms\citep{crosscompilers}.
It uses dependently-typed automated proofs to reject erroneous
foreign calls, which are checked against an FFI description.
In the case of OCaml, this FFi\_OCaml is described by the types that can be
passed to and from foreign functions, the function names inside namespaces
and a descriptor for exported Idris types.

There is now an IO' a type which is parametrized by such an FFI description.
The default IO became an alias for IO' FFI\_C since C is the default external
environment.

\begin{minted}{haskell}
    data IO' : (lang : FFI) -> Type -> Type 
\end{minted}


\subsection{Exports}
Exports are the Foreign counterparts. They work the other way around,
meaning they could be used to call Idris code from OCaml.

However, this is more complicated as Idris requires that all the exported
functions have their data types exported too and of course.
This makes sense because they would not be useful if they could only call
OCaml code.
Exported functions also need to satisfy the same type predicates as the
foreign calls, for their return types and the types of their arguments.

Another limitation is that only monomorphic types can be exported. OCaml
does support polymorphic types but many other languages don't.
Therefore, types like \emph{Maybe a} cannot be exported.

\subsection{Idris libraries}
Ultimately, an user-friendly method of using the OCaml environment must be
available to other Idris programs.

Idris comes with a basic package manager which was used to wrap a small typed
API around the IO' FFI\_OCaml in a library that other programs can install
and import to access the backend.

\section{The Runtime}
This is like a black box. It is where the Malfunction compilation
units end up executing
The overall system has no control over what happens at this stage
once the program is compiled to the binary. Its job is to ensure that
the Foreign System semantics is preserved in the code that CG
generates. If this is not ensured, the programs will have
undefined behaviour during execution, crashing in unexpected ways.

A form of runtime support is provided through the use of
OCaml libraries that Malfunction can interact with in order to
implement certain primitives. This project created the Idrisobj
library as a wrapper around the OCaml Obj which Malfunction can't
access directly because it doesn't implement certain OCaml
primitives.