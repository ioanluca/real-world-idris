\section{Overview}

``Real World Idris'' aims to enhance the Idris ecosystem by building a Foreign
Function Interface (FFI) to OCaml, to be used as a mechanism for calling
functions and services written in OCaml from Idris.

The idea of this upgrade is to enable Idris programs to build on top of
``battle-tested'' software which would ultimately make Idris more suitable
for practical programming.
For instance, one could write a secure, high-performance network application in Idris running as a unikernel constructed by MirageOS, an OCaml built library
operating system.
This functionality will be added on top of the Idris-Malfunction compiler
back-end.

\section{Background}

\subsection{Idris}
% Idris intro
Idris is a general purpose, dependently typed programming language that has an
advanced type system which encodes complex properties about programs into
types, which means that the compiler checks the programs for correctness
before they run.
This technique is described as ``Type-Driven development'' and Idris leverages
types as the foundation of the code, allowing relationships and assumptions to
be expressed using language constructs directly.

Idris is at the forefront of a new generation of programming languages
that support “lightweight verification” --- specifications are defined
early during development, enabling writing maintainable code that is
guaranteed to work.
This has the potential to drastically reduce the costs of reliable software by
integrating verification into development, instead of considering it a separate
concern.

% Idris is new and slow, maybe hard?
Despite being novel and popular in the Programming Language research community
Idris did not catch the attention of the industrial developer communities.
This resulted in a lack of reliable, secure and optimized tools and libraries
in the Idris ecosystem.
Firstly, despite having an extensible compiler that targets more than one
platform, the Idris main/native runtime currently lags wise behind
its industry competitors in terms of performance.
% Talk more about the industry adopting a new language? maybe research
% TODO how intuitive and easy to learn is it
Secondly, Idris has a steep learning curve partly because it requires
a somewhat strong background in functional programming on which it relies
heavily.
In addition, the ``Type Driven'' paradigm is based on the Dependent Types
theory which is widely inaccessible outside the academic world.

\subsection{OCaml}
% intro (as described in the OCaml homepage) TODO ML language family
OCaml is a general purpose industrial-strength functional programming language
with a high-performance runtime system that focuses on safety and
expressiveness.

Since its development has started in 1996, an active community of
academics and their industry counterparts have contributed to a rich set of
libraries and tools for building advanced, secure and reliable software. Mirage
is an example of such a system.

\subsection{Mirage}
Mirage is a library operating system written in OCaml, used to build network
applications with an emphasis on safety and speed.
Such an application is designed to run as a unikernel that can be deployed
across a variety of platforms.

% Library OS
A library OS offers typical functionality, such as networking,
in the form of a collection of software libraries that can be mixed with
configuration code to encapsulate an application in a unikernel.

% Unikernel
Unikernels are specialized machine images.
They are said to be ``single address space'' because they provide only one
address space that is shared globally between all processes.
Unikernels can run directly on a so called hypervisor --- a piece of hardware,
firmware or software that creates and runs virtual machines.

% wrap up
In essence, Mirage enables programmers to select a minimal set of OS specific
low-level functionality required for their applications which are then deployed
as fixed-purpose programs that don't need an underlying OS to be executed.

\subsection{The Idris-Malfunction compiler back-end}
Recently work has been put into solving the Idris performance gap by creating a
new code generation back-end that compiles Idris to Malfunction --- a thin
wrapper around the OCaml Lambda intermediate representation.
Malfunction is then compiled to native code by the OCaml compiler using
``flambda'' optimizations for common high level abstractions found in functional languages --- higher-order functions, parametric polymorphism,
higher-kinded types, lambdas --- anonymous functions, pattern matching and
lazy evaluation.

% TODO cite myself and Bob? 
% This back-end was developed by myself, being supervised by Dr. Robert Atkey
% as part of a research internship within the Mathematically Structured
% Programming (MSP) group at the University of Strathclyde.



\section{Objectives}

The work will involve mapping the OCaml types to Idris equivalents,
implementing the Foreign Function Interface and there will also be
opportunities to fix some of the ergonomic issues within the current
Idris-Malfunction project.

The upgrade will be carried out using the Haskell programming language which is
what the compiler back-end is currently written in.
It will, however, involve coding in OCaml and Idris as well.

Upon completion of a working FFI, an HTTP server will be written in Idris as
proof of concept.
The server will be deployed to either a chip or to AWS.

\subsection{Basic}
Use the provided high level data types for describing foreign function
function calls in order to implement a simple Foreign Function Interface (FFI).
Specifically, it should be possible to call simple
functions --- that return
and accept primitive types, from OCaml.
For example, calling functions like
\(val \ floor : float \rightarrow float\) from Idris.

This should be achieved by using the foreign function call construct in Idris
and defining parts of the fields defined in the FFI record, namely:
\begin{itemize}
	\item the predicate $ffi\_types$ that describes which types can be
	      passed to and from foreign functions
	\item the type of function descriptors $ffi\_fn$
	\item the type of exported data descriptors $ffi\_data$
\end{itemize}

\subsection{Intermediate}
Export Idris monomorphic functions like
$not \ : \ Bool \rightarrow Bool$ to ``header'' files, so that they can be
called from OCaml, via the Idris-Malfunction back-end.
Describing the foreign exports can be achieved by implementing the
$FFI\_Export$ type in Idris.

Support conversion between Idris high level types and OCaml types,
being able to safely exchange complex data.
More specifically, come up with ways of mapping data types like records and
functions to OCaml equivalents.
The challenging parts will involve finding a general strategy for converting
dependent types to regular types that exist in OCaml. However, not all the types are required --- indeed, some may be inappropriate or impossible in this
case.

\subsection{Advanced}
Prove the underlying concept of the project --- create and deploy a Mirage
unikernel that runs a networking application (HTTP) written in Idris and
deploy it to a chip (ESP32) or cloud (Amazon Web Services):
\begin{itemize}
	\item create Idris bindings for the required Mirage modules
	\item write a configuration file for Mirage
	\item deploy to the target platform
\end{itemize}



\section{Preliminary survey of related work}
The ``Cross-platform Compilers for Functional Languages'' draft
research paper by Edwin Brady, the creator of Idris,
provided useful insights about the generic FFI in Idris.

The C and JavaScript code generation back-ends that are distributed
with the official Idris platform show the steps they take to
support interfacing with the target languages.

A study of basic programs written in OCaml and Idris was performed to gain an
initial understanding of their type systems.

An initial reading on unikernels and how they
work in the context of Mirage was done.

A meeting with Lucas Pluvinage took place at ICFP'18 where a discussion
about his recent successful work in compiling Mirage to an ESP32 chip turned
out to be an inspiring opportunity for this project.
His talk where he described his work in more detail was attended as part of the
OCaml workshop.

Ultimately, opportunities to fix some of the ergonomic issues
with the current Idris-Malfunction back-end have been
identified.
Some preliminary work will include:
\begin{itemize}
	\item dummy parameter optimization
	\item support for Unicode
	\item improve compilation time
	\item code generation refactoring
	\item implement any non-implemented Idris primitives
	\item find a reasonably good trade off regarding block
	      tags being limited to 200
	\item test BigIntegers
	\item deal with floating point numbers
	\item bump to latest Idris, Stack, Opam and OCaml
\end{itemize}


\section{Methodology}
The current plan is to develop this project using an Agile
methodology and document progress as often as possible.
The idea is to start writing the report and the source code early and keep
them synchronized throughout the stages of the project.

\subsection{Specification}
The specification will start as a more detailed description of the
deliverables and it will be added on to as the project evolves and more
features can be identified.
Finally, it needs to accurately resemble the accompanying artefact at all times.
\subsection{Design}
The design will heavily be influenced by other Idris code generation back-ends
and the FFI upgrade has to fit nicely in the current Idris-Malfunction back-end.
As it is usually the case with Agile development, the design will suffer many
iterations.
\subsection{Implementation}
The report will be written using *Tex technologies while the software part will
involve coding in Haskell, Idris and OCaml on a Unix system.
The VSCode text editor with specific plug-ins installed will serve as
development environment, while Trello is going to aid
project management.
Version control will be carried out using Git.
Stack will be leveraged as a build tool.
More software that automates the Software Development Life Cycle
will need to be used --- Travis for continuous integration for instance.

\subsection{Verification}
To test the Haskell code base, some of the following will be used:
\begin{itemize}
	\item QuickCheck or SmallCheck --- generative testing
	\item HUnit for --- testing
	\item Criterion --- benchmarking
	\item HSpec or Tasty --- testing framework wrapper
\end{itemize}

\subsection{Evaluation}
Evaluation will mainly consist of writing Idris code that uses OCaml bindings
and testing that it has the correct behaviour.
Moreover, Idris and OCaml semantically equivalent programs should behave
the same.
This will also be an incremental process.
Even from the very beginning stages of development, small Idris programs should
should be built to test small bits of functionality.
This will provide confidence when attempting to extend pieces of functionality
and then more complex Idris programs can be built on top of the small ones.
Nevertheless, some things will have to be tested in isolation as well.

Upon completion of the advanced deliverable, the running Idris networking
application will be validated for correctness.