The following research was done in order to carry out this
project.

\section{Idris and Dependent Types}
In recent years, dependently-typed programming languages such
as Agda\footnote{https://wiki.portal.chalmers.se/agda/pmwiki.php}
and Coq\footnote{https://coq.inria.fr/} have been developed.
They are promising mechanisms for ensuring software correctness
by encoding the specification of programs in the type system.
This is only possible because the types are predicated by values,
which makes types very precise.
This way, by type checking, the compiler essentially produces a
mathematical proof that the program behaves as intended when
executing \citep{brady_2013}.

While Agda and Coq emerged from the theorem proving community,
Idris is more oriented towards general purpose programming. For
example, it is possible to use dependent types to specify and
verify properties of a network packet processing
system at compile time.\citep{systemprog}.


% \begin{lstlisting}[caption=asd]
% data List : (elem : Type) -> Type where
%   Nil : List elem
%   (::) : (x : elem) -> (xs : List elem) -> List elem 
% \end{lstlisting}

% \begin{lstlisting}
% data Vect : (len : Nat) -> (elem : Type) -> Type where
%   Nil  : Vect Z elem
%   (::) : (x : elem) -> (xs : Vect len elem) -> Vect (S len) elem
% \end{lstlisting}

According to \citep{brady_2013}, Idris is the answer to the following
question:
\emph{``What if Haskell had full dependent types?''}
Indeed, Idris is heavily inspired by Haskell from which it
borrows many of its features including do notation,
interfaces\footnote{very similar to Haskell type
    classes}, where clauses, let expressions, case expressions and
Generalized Algebraic Data Types (GADTs).
The Idris syntax is also very similar to Haskell'.

However, unlike Haskell, Idris is eagerly evaluated but has
support for lazy evaluation.
Eager or strict evaluation is what most of the languages
use by default and means that expressions are evaluated
as soon as they are bound to a variable.
For example, arguments are evaluated before they are passed
to a function call.
In contrast, lazy evaluation delays the evaluation of expressions for
as long as possible.
That is, function calls are evaluated before the arguments which
are only evaluated when something that depends on them requests to
be evaluated.
This makes it harder to reason about execution of programs but can
implement interesting infinite data structures like streams.

Idris is under active development lead by Edwin Brady.

\section{OCaml}
OCaml is a general purpose industrial-strength functional
programming language with a high-performance runtime system

According to \citep{rwocaml}, OCaml plays an important role in the
world of programming language design because it provides a mix
of expressiveness, efficiency and practicality.
This mix, is in fact a collection of carefully chosen features
that have been developed over the last 40 years.

Since its development has started in 1996, an active community of
academics and their industry counterparts have contributed to a rich set of
libraries and tools for building advanced, secure and reliable software
using OCaml.
Later in this chapter, we discuss \hyperref[sec:mirage]{Mirage} which is
an example of such a system.

The OCaml compiler benefits from a simple
compilation strategy that doesn't require heavy optimizations or
complicated dynamic just-in-time (JIT) features to produce performant
code. Moreover, OCaml is strictly evaluated just like Idris which
makes it easy to predict performance.
The language uses  a precise incremental garbage collection strategy
that avoids spikes while the runtime is straightforward and highly
portable.

Normally, what also makes OCaml practical, is that it supports some
imperative programming style constructs like mutable references,
side effects and even objects.
However, release 4.02 brought the \emph{flambda} optimisations to the
native compiler. They are a series of tweaks
that enable idiomatic functional programming characteristics like clojures,
higher-order functions and immutability to be used at no extra
performance cost.\citep{leroy2014ocaml}

All these properties, together with the extensive support
for functional programming make OCaml's runtime a great
candidate for Idris, as the 2 languages have a lot in common.

\section{Malfunction}
Malfunction is minimal, untyped program representation intended as a
compilation target for functional languages.

Malfunction is in fact a thin wrapper around the Lambda intermediate
representation (IR) of OCaml meaning that compilers targeting it
are compiled to native code by the OCaml compiler enjoying the
\emph{flambda} optimisations and the garbage collector mentioned
earlier \citep{dolan2016malfunctional}.

In a way, it serves the same purpose as the Java Virtual Machine (JVM)
bytecode, although it is much more high-level as
to suit functional languages. For instance, Malfunction has
let bindings, recursive definitions, lambdas, very basic case
expressions, higher order functions and arguments currying.

As it us usually the case with low-level untyped languages, Malfunction
has undefined behaviour.
Its semantics is that of Lambda, namely an untyped lambda calculus but
stricter in certain places which make it more robust to changes in the
OCaml toolchain.
\citep{dolan2016malfunctional}.

Similarly, its syntax is based on s-expressions\footnote{
    what Lisp looks like
} which are easy to generate from many abstract syntax trees (ASTs).
\hyperref[lst:mlfex]{Listing~\ref{lst:mlfex}} shows mutually recursive
functions that determine a number's parity.

\begin{lstlisting}[label={lst:mlfex}, caption=
    Mutually recursive functions in Malfunction
    ]
    (let
    (rec
      ($even (lambda ($n) 
        (if (<= $n 1) (== $n 0) (apply $odd (- $n 1)))))
      ($odd (lambda ($n) 
        (if (<= $n 1) (== $n 1) (apply $even (- $n 1))))))
    ($res (apply $even 42))
    $res)
  => 1
\end{lstlisting}

Malfunction primitive types are strings and integers with
different precisions and common arithmetic operations
work. The language also has the ability to call OCaml code as long
as it is located on the standard library path.
\hyperref[lst:mlfforeign]{Listing~\ref{lst:mlfforeign}}
shows code that prints the contents of a list of strings in both
languages.

\begin{lstlisting}[label={lst:mlfforeign}, caption=
    Calling OCaml code from Malfunction]
    (apply
        (global $List $iter)
        (global $Pervasives $print_string)
            (block "Hello" (block "World" 0)))

    ; is equivalent to the following OCaml code
    List.iter print_string ["Hello"; "World"]
\end{lstlisting}
% \lstinputlisting{../../../test-idris/cohttp/cohttp.mlfa}

Recently, Malfunction received an upgrade.
Now it also supports lazy evaluation and
floating point numbers.

Considering all of the above, Malfunction represents a good
solution for connecting Idris to the OCaml runtime.

\subsection{Idris Code Generators}
Idris is intended for general use. \citep{crosscompilers} argues
that this raises the need for Idris to run in various, potentially
very different environments.

For example, it is possible to generate C to have Idris run
natively or JavaScript to run in the browser.

To address this concern, Idris provides a modular compiler
infrastructure as a Haskell library in which different code
generators can easily be plugged in.
According to \citep{crosscompilers},
the library exposes 4 different intermediate representations outside
of Idris itself:
\begin{enumerate}
    \item TT --- a core language based on dependent type theory; fully
          explicit types still exist at this stage, but the only top level
          constructs are the data type declarations and function definitions
          with pattern matching transformed into case expressions
    \item IR\textsubscript{lift} --- essentially TT type checked; unused values
          and types are erased;
    \item IR\textsubscript{defunc} --- all functions are first-order
          and fully applied after defunctionalisation is performed
    \item IR\textsubscript{ANF} --- all are functions are in
          \emph{Applicative Normal Form} where all arguments are trivial;
          in practice that means they are either variables or constants;
          Idris can even generate a form of bytecode for a simple
          stack-based machine from this IR
\end{enumerate}
They all resemble the same information but at different levels
of abstraction. This is because they assume certain sets of features
in the target language such that choosing a rich IR
for a low-level language would be a bad idea
\citep{ElliottIdrisErlang}.


A code generator is a program that type checks and elaborates
Idris programs using this library.
It has to choose exactly one
IR to generate code from.
The process of creating a new code generator is well
documented by \citep{ElliottIdrisErlang} which also does a great job
at specifying the Idris IRs and the primitives.

The user can specify the code generator Idris should use with
the \emph{--codegen} flag.
The C code generator is the default.

The same paper proposes a generic foreign function interface that
supports multiple platforms through dependent types.

Some of the researched code generation backends are outlined
below.

\subsubsection{Idris-Malfunction}

Originally, Stephen Dolan, the author of Malfunction created a
version\footnote{hosted at
    \url{https://github.com/stedolan/idris-malfunction}}
of this backend \citep{dolan2016malfunctional}.
Although incomplete, preliminary benchmarks showed that it was
outperforming the default C backend by a factor between 3.2x and 14x
which sounded promising.

% todo slow tags 
Besides missing a lot of functionality, the backend was generating
inefficient code for Idris constructors which were always wrapped
in a block of memory regardless whether they had any parameters.
No parameters constructors can in fact map to integers directly.
Moreover, the code was generated from IR\textsubscript{ANF}
which did not seem optimal given that Malfunction has
good support for higher-order functions.
This is especially true now that laziness was added to Malfunction.

Nevertheless, this version of the backend was a good place to start
and build on.

The current version of the backend which I built chooses
to generate code from IR\textsubscript{lift} which seems to
slightly improve the already good performance.

The backend was tested with a range of benchmarks against the
C backend:

\subsubsection{Benchmark results}
The Unix ``time'' command was used as part of the binaries execution
and all output was redirected to /dev/null \citep{self}.
See tables \hyperref[tab:fibtab]{\ref{tab:fibtab}},
\hyperref[tab:pythagtab]{\ref{tab:pythagtab}} and
\hyperref[tab:bintreetab]{\ref{tab:bintreetab}}.

\begin{table}
    \centering
    \caption{40th Fibonacci number --- naive}
    \begin{tabular}{llll}\label{tab:fibtab}
             & C      & OCaml  & \\
        real & 5.050s & 3.851s & \\
        user & 5.034s & 3.846s & \\
        sys  & 0.01s  & 0.04s  &
    \end{tabular}
\end{table}

\begin{table}
    \centering
    \caption{Generate the first 500 Pythagorean triplets in a linked list}
    \begin{tabular}{llll}\label{tab:pythagtab}
             & C      & OCaml  & \\
        real & 3.163s & 0.417s & \\
        user & 3.131s & 0.416s & \\
        sys  & 0.027s & 0.01s  &
    \end{tabular}
\end{table}


\begin{table}
    \centering
    \caption{Allocation of a perfect binary tree to \emph{stretch} memory, which then is deallocated, followed by an allocation of a long-lived perfect binary tree which will live-on while other trees are allocated and deallocated}
    \begin{tabular}{llll}\label{tab:bintreetab}
             & C       & OCaml   & \\
        real & 58.114s & 18.967s & \\
        user & 44.036s & 18.540s & \\
        sys  & 13.980s & 0.346s  &
    \end{tabular}
\end{table}



\section{Unikernels and MirageOS}\label{sec:mirage}
the rise of the library OS