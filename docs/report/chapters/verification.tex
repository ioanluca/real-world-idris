%10
\section{Approach}

Verification has mostly been done manually, by writing Idris programs
and then compiling them against both the OCaml backend and C backend
(sometimes even the JavaScript backend) verifying that they have the
same behaviour after execution.


For example, the following is a test case that succeeds.
It checks whether mutual recursion works.

% \begin{listing}[H]
%     \begin{minted}[linenos]{haskell}
%     \end{minted}
%     \caption{Various calls to the OCamld backend via Idris}
%     % \label{lst:}
% \end{listing}


\begin{listing}[H]
    \begin{minted}[linenos]{haskell}
module Main 

mutual
  even : Nat -> Bool
  even Z = True
  even (S k) = odd k

  odd : Nat -> Bool
  odd Z = False
  odd (S k) = even k

main : IO ()
main = putStrLn $ show $ even $ sum [1,3,4,5,2]
    \end{minted}
    \caption{Test Idris Mutual Recursion in the OCaml backend}
    % \label{lst:}
\end{listing}

Similarly, for testing the foreign calls via Idris, the behaviour was checked
vs equivalent OCaml function calls (usually in Utop).
\begin{listing}[H]
    \begin{minted}[linenos]{haskell}
import OCaml.IO

f : String -> (String, Maybe Double)
f x = (x ++ x, Just (1.3 + 1.3))


main : OCaml_IO ()
main = do 
     min_int <- ocamlCall "Pervasives.min_int" (OCaml_IO Int)
     printLn min_int
     ic <- ocamlCall "Pervasives.open_in"
      (String -> OCaml_IO Ptr) "Foo.idr"
     str <- ocamlCall "Pervasives.input_line"
         (Ptr -> OCaml_IO String) ic
     l <- ocamlCall "List.length"
         (List Int -> OCaml_IO Int) [1,2,3]
     ll <- ocamlCall "List.flatten" 
         ((List (List Int)) -> OCaml_IO (List Int))
          [[1,2,3], [9,10,11]]
     printLn l
     printLn ll
     printLn str
     ys <- ocamlCall "List.map" 
        ((OCamlFn (Int -> Int)) -> List Int -> OCaml_IO (List Int)) 
         (MkOCamlFn (+1)) [1..10]
     printLn ys
     zs <- ocamlCall "List.map"
        ((OCamlFn (String -> (String, Maybe Double)))
         -> List String ->
          OCaml_IO (List (String, Maybe Double)))
        (MkOCamlFn f) ["hello", "world"]
     printLn zs
     ocamlCall "List.iter" 
        ((OCamlFn (Double -> ())) -> List Double -> OCaml_IO ()) 
        (MkOCamlFn (\ x => unsafePerformIO $ Interactive.printLn x)) 
        [1.1,213.321]
    \end{minted}
    \caption{Various calls to the OCamld backend via Idris}
    % \label{lst:}
\end{listing}



