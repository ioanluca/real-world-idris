\documentclass{beamer}
 
\usepackage[utf8]{inputenc}
\title{Real World Idris}
\subtitle{Project Progress Presentation}
\author{Ioan Luca \\ 201638554 \\ \small supervisor: Dr Robert Atkey \\
	\small second marker: Dr Dmitri Roussinov \\}
\institute{University of Strathclyde}
\date{\today}

 
\begin{document}



\frame{\titlepage}


\begin{frame}
	\frametitle{A little bit about Idris}
	\begin{itemize}
		\item pure functional language inspired by Haskell
		      \pause
		\item has dependent types, so can encode complex properties
		      \pause
		      about programs into types enabling ``Type-Driven Development''
		\item i.e. allows formal lightweight verification --- proving
		      correctness of programs inside the source code itself,
		      much like mathematical theorem proving
		      \pause
		\item programming becomes a very interactive experience
		      --- devs think about interesting functionality of their programs
		      and the compiler figures out where it is/could be useful
		      \pause
		\item so it's quite new and innovative --- mostly
		      in the academic world at the moment
		      \pause
		\item Idris-Malfunction, recent work to solve the performance gap
	\end{itemize}
\end{frame}


\begin{frame}
	\frametitle{Overview}

	\begin{itemize}
		\item essentially an enhancement of the Idris ecosystem
		      that aims to make it more suitable for practical
		      programming (for the ``Real World'')
		      \pause
		\item a (two-way) Foreign Function Interface (FFI) that
		      allows calling OCaml
		      from Idris and vice-versa --- to be built on top of the
		      compiler backend I wrote
		      \pause
		\item Why? --- OCaml is a very popular ``battle-tested''
		      functional language
		      \pause
		\item Lots of modular, secure and fast software has been written in it
		      \pause
		\item MirageOS is on such example and it works as a library, so we'd
		      like to use Mirage in Idris for instance
		      \pause
		\item to build an HTTP server...
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{Mirage}

	\begin{itemize}
		\item written in OCaml
		      \pause
		\item library OS --- amazing for building safe and
		      blazing fast network apps
		      \pause
		\item basically provides only the minimal set of low-level
		      functionality that your app needs and strips down all the
		      heavy bits of a fully-fledged OS
		      \pause
		\item constructs unikernels that can be deployed on
		      a variety of platforms --- hardware (\$5 ESP32 chip)
		      or hypervisor (AWS)
		      \pause
		\item secure and incredibly fast
	\end{itemize}
\end{frame}


\begin{frame}
	\frametitle{Objectives}

	The work will involve mapping the OCaml types to Idris equivalents,
	implementing the Foreign Function Interface and there will also be
	opportunities to fix some of the ergonomic issues within the
	current Idris-Malfunction code generation project.

	\pause
	\begin{itemize}
		\item Basic	(Currently working on)
		      \pause
		      \begin{itemize}
			      \item basic Idris to OCaml FFI
			            \pause
			      \item described using Idris support for describing
			            foreign function calls
			            \pause
			      \item i.e. fill in fields of the FFI record:
			            $ffi\_types$, $ffi\_fn$, $ffi\_data$
			            \pause
			      \item successfully call simple functions like
			            $val \ floor : float \rightarrow float$
		      \end{itemize}
	\end{itemize}
\end{frame}


\begin{frame}
	\frametitle{Objectives (Intermediate)}

	\begin{itemize}
		\item export Idris monomorphic (types are concrete) functions
		      to OCaml
		      \pause
		\item essentially the other way around
		      \pause
		\item at this point support 2-way conversion between
		      the Idris and OCaml type systems
		      \pause
		\item safely exchanging complex data between the 2 ecosystems
		      \pause
		\item challenging because some of the Idris types don't make
		      sense in OCaml and hence, don't have equivalents
		      \pause
		\item anyway, for now it's only interesting to call OCaml
		      from Idris, but for the sake of completeness
		      \pause
		\item so we need to implement the $FFI\_Export$ type in Idris
		      \pause
		\item successfully export functions like
		      $not \ : \ Bool \rightarrow Bool$ to OCaml header (.mli)
		      files that can then be called
	\end{itemize}
\end{frame}


\begin{frame}
	\frametitle{Objectives (Advanced)}

	Prove the underlying concept of the project --- create and deploy a Mirage unikernel that runs a networking
	application (HTTP) written in Idris and deploy it to a chip (ESP32) or cloud (Amazon Web Services):
	\pause

	\begin{itemize}
		\item create Idris bindings for the required Mirage modules
		      \pause
		\item write a configuration file for Mirage
		      \pause
		\item deploy to the target platform
	\end{itemize}
\end{frame}


\begin{frame}
	\frametitle{Progress to date}

	\begin{itemize}
		\item working on the 1st deliverable
		      \pause
		\item looking at how the C and JavaScript backends implement
		      their FFIs https://github.com/idris-lang/Idris-dev/tree/master/codegen
		      \pause
		\item set up the Development Environment
		      \pause
		\item prototyping with implementing the FFI records from the
		      ``Cross-platform Compilers for Functional Languages'' paper
		      by Edwin Brady
		      \pause
		\item Malfunction has recently been updated (now supports
		      lazy evaluation natively and has floats) so I need
		      to update the code generation back-end
		      \pause
		\item working on fixing some of the ergonomic problems with
		      Idris-Malfunction (dummy parameters optimization, support for Unicode,
		      primitives, bump to latest Idris/Opam/OCaml compilation time)
		      \pause
		\item Getting familiar with Mirage
	\end{itemize}

\end{frame}


\begin{frame}
	\frametitle{Evaluation}

	\begin{itemize}
		\item write Idris code that calls OCaml routines and Services
		      and test for correct behaviour (vice-versa too)
		\item compile programs with the 2 compilers and if
		      they are semantically equivalent then the behaviour should
		      be the same
		\item test early during Development
		\item upon completion of the advanced deliverable,
		      the Idris networking application will be validated for
		      correctness
	\end{itemize}
\end{frame}


\begin{frame}
	\frametitle{Overall project plan}

	\begin{itemize}
		\item week 12 --- 14 Jan - 20 Jan,
		      week 13 --- 21 Jan - 27 Jan \\
		      Implement basic deliverable
		      and start writing
		      the report
		\item week 14 --- 28 Jan - 03 Feb,
		      week 15 --- 04 Feb - 10 Feb \\ Implement the intermediate
		      deliverable and report Testing
		\item week 16 --- 11 Feb - 17 Feb,
		      week 17 --- 18 Feb - 24 Feb,
		      week 18 --- 25 Feb - 03 Mar \\ Attempting the advanced
		      deliverable, Report Testing, \textbf{Mirage}
		\item week 19 --- 04 Mar - 10 Mar,
		      week 20 --- 11 Mar - 17 Mar \\
		      \textbf{week 21 --- 18 Mar - 24 Mar ---
			      Need to be ready by now} \\
		      Validation,
		      Verification,
		      Proofread \\
		      Refactor,
		      Finish Writing up,
		      Prepare Demo
		\item \textbf{week 22 --- 25 Mar - 27 Mar ---
			      Submission Monday 25, 12:00
			      Demo is on Wednesday 27} \\ Hooray!
	\end{itemize}
\end{frame}



\end{document}